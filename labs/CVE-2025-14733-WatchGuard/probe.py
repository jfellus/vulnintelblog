import base64
import socket
import struct
import os
import re

HOST = "10.0.10.1"
PORT = 500

# IKEv2 Constants
PAYLOAD_SA = 33
PAYLOAD_KE = 34
PAYLOAD_NONCE = 40
PAYLOAD_NOTIFY = 41
PAYLOAD_VENDOR = 43
PAYLOAD_NONE = 0
EXCHANGE_IKE_SA_INIT = 34
DH_GROUP_14 = 14


def build_ike_sa_init() -> tuple[bytes, bytes]:
    """
    Build an IKE_SA_INIT request packet

    Borrowed from:
    """
    initiator_spi = os.urandom(8)

    def build_transform(t_type, t_id, attrs=b"", is_last=False):
        length = 8 + len(attrs)
        flag = 0 if is_last else 3
        return struct.pack(">BBHBBH", flag, 0, length, t_type, 0, t_id) + attrs

    transforms = [
        build_transform(1, 12, struct.pack(">HH", 0x800E, 256)),  # AES-CBC-256
        build_transform(2, 5),  # PRF-HMAC-SHA2-256
        build_transform(3, 12),  # AUTH-HMAC-SHA2-256-128
        build_transform(4, 14, is_last=True),  # DH Group 14
    ]
    transforms_data = b"".join(transforms)

    proposal_len = 8 + len(transforms_data)
    proposal = struct.pack(">BBHBBBB", 0, 0, proposal_len, 1, 1, 0, 4) + transforms_data

    sa_len = 4 + len(proposal)
    sa_payload = struct.pack(">BBH", PAYLOAD_KE, 0, sa_len) + proposal

    ke_data = os.urandom(256)
    ke_len = 8 + len(ke_data)
    ke_payload = (
        struct.pack(">BBHHH", PAYLOAD_NONCE, 0, ke_len, DH_GROUP_14, 0) + ke_data
    )

    nonce_data = os.urandom(32)
    nonce_len = 4 + len(nonce_data)
    nonce_payload = struct.pack(">BBH", PAYLOAD_NONE, 0, nonce_len) + nonce_data

    payloads = sa_payload + ke_payload + nonce_payload
    total_len = 28 + len(payloads)

    header = struct.pack(
        ">8s8sBBBBII",
        initiator_spi,
        b"\x00" * 8,
        PAYLOAD_SA,
        0x20,
        EXCHANGE_IKE_SA_INIT,
        0x08,
        0,
        total_len,
    )

    return header + payloads, initiator_spi


def parse_ike_response(data: bytes, our_spi: bytes) -> dict:
    """
    Parse IKE response and extract information

    Borrowed from:
    """
    result = {
        "valid": False,
        "version": None,
        "build": None,
        "vendor_ids": [],
        "is_watchguard": False,
    }

    if len(data) < 28:
        return result

    # Check if our SPI is echoed back
    if data[:8] != our_spi:
        return result

    # Parse header
    next_payload = data[16]
    version = data[17]

    if version != 0x20:  # Not IKEv2
        return result

    result["valid"] = True

    # Parse payloads looking for Vendor ID
    offset = 28
    current_payload = next_payload

    while current_payload != PAYLOAD_NONE and offset < len(data):
        if offset + 4 > len(data):
            break

        np = data[offset]
        payload_len = struct.unpack(">H", data[offset + 2 : offset + 4])[0]

        if payload_len < 4 or offset + payload_len > len(data):
            break

        payload_data = data[offset + 4 : offset + payload_len]

        if current_payload == PAYLOAD_VENDOR:
            # Try to decode vendor ID as string
            try:
                vendor_str = payload_data.decode("utf-8", errors="ignore")
                result["vendor_ids"].append(vendor_str)

                # Check for WatchGuard indicators
                if "WatchGuard" in vendor_str or "Firebox" in vendor_str:
                    result["is_watchguard"] = True

                # Try to extract version
                if "VN=" in vendor_str:
                    try:
                        vn_start = vendor_str.index("VN=") + 3
                        vn_end = vendor_str.find(" ", vn_start)
                        if vn_end == -1:
                            vn_end = len(vendor_str)
                        result["version"] = vendor_str[vn_start:vn_end]
                    except (ValueError, IndexError):
                        pass

                if "BN=" in vendor_str:
                    try:
                        bn_start = vendor_str.index("BN=") + 3
                        bn_end = vendor_str.find(" ", bn_start)
                        if bn_end == -1:
                            bn_end = len(vendor_str)
                        result["build"] = vendor_str[bn_start:bn_end]
                    except (ValueError, IndexError):
                        pass
            except UnicodeDecodeError:
                result["vendor_ids"].append(payload_data.hex())

            # WatchGuard uses binary hash prefix + base64 version string
            # Format: 32-byte hash + base64("VN=12.11.4 BN=722644")
            if len(payload_data) >= 40:
                # Look for base64 pattern in the payload (starts after binary prefix)
                for start_offset in [32, 28, 24]:
                    if start_offset >= len(payload_data):
                        continue
                    b64_candidate = payload_data[start_offset:]
                    try:
                        decoded = base64.b64decode(b64_candidate).decode("utf-8")
                        # Check if it looks like WatchGuard version format
                        if "BN=" in decoded and "." in decoded:
                            result["is_watchguard"] = True
                            for part in decoded.split(" "):
                                if part.startswith("VN="):
                                    result["version"] = part[3:]  # Strip VN= prefix
                                elif part.startswith("BN="):
                                    result["build"] = part[3:]
                                elif "." in part and part[0].isdigit():
                                    # Version without VN= prefix
                                    result["version"] = part
                            break
                    except (base64.binascii.Error, UnicodeDecodeError, ValueError):
                        continue

        offset += payload_len
        current_payload = np

    return result


def check_vulnerable_version(version: str) -> bool | None:
    """
    Check if a Fireware version string is in WatchGuard's affected ranges for CVE-2025-14733:
      - 11.10.2 through 11.12.4_Update1
      - 12.0 through 12.11.5
      - 2025.1 through 2025.1.3
    """
    if m := re.search(
        r"(\d{2,4})\.(\d+)(?:\.(\d+))?(?:[_\- ]?Update(\d+))?",
        re.sub(r"^[^0-9]+", "", version.strip()),  # Strip non-digit prefix
        re.I,
    ):
        major = int(m.group(1))
        minor = int(m.group(2))
        patch = int(m.group(3) or 0)
        update = int(m.group(4) or 0)
        return (
            # 11.10.2 -> 11.12.4_Update1
            ((major == 11) and (10, 2, 0) <= (minor, patch, update) <= (12, 4, 1))
            # 12.0 -> 12.11.5
            or ((major == 12) and (0, 0, 0) <= (minor, patch, update) <= (11, 5, 0))
            # 2025.1 -> 2025.1.3
            or ((major == 2025 and minor == 1) and (0, 0) <= (patch, update) <= (3, 0))
        )


IKE_SA_INIT, our_spi = build_ike_sa_init()

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(5)
sock.sendto(b"prout", (HOST, PORT))  # Dummy packet to open NAT bindings
sock.sendto(IKE_SA_INIT, (HOST, PORT))

try:
    data, addr = sock.recvfrom(4096)
    print(data, addr)

    res = parse_ike_response(data, our_spi)
    if (
        res["valid"]
        and res["is_watchguard"]
        and check_vulnerable_version(res["version"])
    ):
        print(
            "ðŸ’¥ This WatchGuard Firebox instance is POTENTIALLY VULNERABLE to CVE-2025-14733 !"
        )
    else:
        print(
            "âœ… This WatchGuard Firebox instance is NOT vulnerable to CVE-2025-14733 !"
        )

except socket.timeout:
    print("Timeout... probably filtered")
